import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import curve_fit
import os

def exponential_decay(t, A, lambda_val, target):
    """指数衰减函数: value(t) = target + A * exp(-lambda_val * t)"""
    return target + A * np.exp(-lambda_val * t)

def exponential_fit(time_points, values, target, max_time=None):
    """拟合指数衰减曲线"""
    try:
        # 确保数据有效
        valid_mask = ~np.isnan(values) & ~np.isinf(values)
        time_points = time_points[valid_mask]
        values = values[valid_mask]
        
        # 如果指定了最大时间，只使用该时间段内的数据
        if max_time is not None:
            mask = time_points <= max_time
            time_points = time_points[mask]
            values = values[mask]
        
        if len(time_points) < 3:
            return 0, 0, np.zeros_like(time_points) + target
        
        # 初始参数估计
        initial_A = np.abs(values[0] - target)
        initial_lambda = 0.1
        
        # 拟合曲线
        popt, pcov = curve_fit(
            lambda t, A, lambda_val: exponential_decay(t, A, lambda_val, target),
            time_points, values,
            p0=[initial_A, initial_lambda],
            maxfev=5000
        )
        A_fit, lambda_fit = popt
        fitted_curve = exponential_decay(time_points, A_fit, lambda_fit, target)
        return lambda_fit, A_fit, fitted_curve, time_points
    except:
        # 如果拟合失败，返回默认值
        return 0, 0, np.zeros_like(time_points) + target, time_points

def extract_recovery_data(df, mu, hgt, replicate):
    """提取特定参数组合的恢复期数据"""
    subset = df[(df['mu'] == mu) & (df['hgt'] == hgt) & (df['replicate'] == replicate)]
    if len(subset) == 0:
        return None
    
    # 从第21代开始（冲击结束后）
    recovery_data = subset[subset['generation'] >= 21].copy()
    if len(recovery_data) == 0:
        return None
    
    # 相对时间（第21代为时间0）
    recovery_data['recovery_time'] = recovery_data['generation'] - 21
    return recovery_data

def plot_dual_fit_recovery(df, mu, hgt, replicate, short_term_max=10):
    """为单个参数组合绘制包含短期和长期拟合的恢复分析图"""
    recovery_data = extract_recovery_data(df, mu, hgt, replicate)
    if recovery_data is None or len(recovery_data) < 3:
        print(f"跳过 μ={mu}, ι={hgt}, 重复{replicate}: 数据不足")
        return None
    
    # 获取目标值（第15代的值）
    target_data = df[(df['mu'] == mu) & (df['hgt'] == hgt) & 
                    (df['replicate'] == replicate) & 
                    (df['generation'] == 15)]
    if len(target_data) == 0:
        print(f"跳过 μ={mu}, ι={hgt}, 重复{replicate}: 无目标数据")
        return None
    
    target_price = target_data['avg_price'].iloc[0]
    target_quality = target_data['avg_quality'].iloc[0]
    
    # 时间点和实际数据
    time_points = recovery_data['recovery_time'].values
    actual_prices = recovery_data['avg_price'].values
    actual_qualities = recovery_data['avg_quality'].values
    
    # 进行两种拟合
    # 短期拟合（前short_term_max代）
    lambda_price_short, A_price_short, fitted_prices_short, time_short = exponential_fit(
        time_points, actual_prices, target_price, max_time=short_term_max
    )
    
    lambda_price_long, A_price_long, fitted_prices_long, time_long = exponential_fit(
        time_points, actual_prices, target_price
    )
    
    lambda_quality_short, A_quality_short, fitted_qualities_short, _ = exponential_fit(
        time_points, actual_qualities, target_quality, max_time=short_term_max
    )
    
    lambda_quality_long, A_quality_long, fitted_qualities_long, _ = exponential_fit(
        time_points, actual_qualities, target_quality
    )
    
    # 创建图形
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 10))
    
    # 颜色定义
    price_color = '#FF5722'  # 深橙色（夕阳色）
    quality_color = '#2980B9'  # 深蓝色
    short_fit_color = '#C44D58'  # 短期拟合颜色（深红）
    long_fit_color = '#556270'  # 长期拟合颜色（深蓝）
    target_color = '#45B7D1'  # 目标线颜色（青色）
    
    # 图1: 平均价格恢复
    ax1.plot(time_points, actual_prices, 'o-', color=price_color, linewidth=2,
            markersize=5, label='Actual Price', alpha=0.7, markerfacecolor=price_color)
    
    # 绘制短期拟合（只显示在短期区间）
    short_mask = time_short <= short_term_max
    if len(time_short[short_mask]) > 0:
        ax1.plot(time_short[short_mask], fitted_prices_short[short_mask], '--', 
                color=short_fit_color, linewidth=2.5,
                label=f'Short-term Fit (λ={lambda_price_short:.3f})')
    
    # 绘制长期拟合
    ax1.plot(time_long, fitted_prices_long, '--', color=long_fit_color, linewidth=2,
            label=f'Long-term Fit (λ={lambda_price_long:.3f})')
    
    ax1.axhline(y=target_price, color=target_color, linestyle=':', linewidth=2,
               label=f'Target Price ({target_price:.1f})')
    
    # 标记短期拟合区域
    ax1.axvline(x=short_term_max, color='gray', linestyle='--', linewidth=1, alpha=0.5)
    ax1.text(short_term_max, ax1.get_ylim()[1]*0.95, f'Short-term\nregion', 
            fontsize=8, ha='right', va='top', color='gray')
    
    ax1.set_xlabel('Recovery Time (Generations since shock end)', fontsize=12)
    ax1.set_ylabel('Average Price', fontsize=12)
    ax1.set_title(f'Price Recovery Trajectory\nμ={mu}, ι={hgt}, Replicate={replicate+1}',
                 fontsize=14, fontweight='bold')
    ax1.legend(fontsize=9, loc='best')
    ax1.grid(True, alpha=0.3)
    
    # 添加衰减率信息框
    textstr = (f'Short-term λ: {lambda_price_short:.3f} (A={A_price_short:.1f})\n'
              f'Long-term λ: {lambda_price_long:.3f} (A={A_price_long:.1f})')
    props = dict(boxstyle='round', facecolor='wheat', alpha=0.8)
    ax1.text(0.02, 0.98, textstr, transform=ax1.transAxes, fontsize=9,
            verticalalignment='top', bbox=props)
    
    # 图2: 平均质量恢复
    ax2.plot(time_points, actual_qualities, 'o-', color=quality_color, linewidth=2,
            markersize=5, label='Actual Quality', alpha=0.7, markerfacecolor=quality_color)
    
    # 绘制短期拟合
    short_mask = time_short <= short_term_max
    if len(time_short[short_mask]) > 0:
        ax2.plot(time_short[short_mask], fitted_qualities_short[short_mask], '--', 
                color=short_fit_color, linewidth=2.5,
                label=f'Short-term Fit (λ={lambda_quality_short:.3f})')
    
    # 绘制长期拟合
    ax2.plot(time_long, fitted_qualities_long, '--', color=long_fit_color, linewidth=2,
            label=f'Long-term Fit (λ={lambda_quality_long:.3f})')
    
    ax2.axhline(y=target_quality, color=target_color, linestyle=':', linewidth=2,
               label=f'Target Quality ({target_quality:.1f})')
    
    # 标记短期拟合区域
    ax2.axvline(x=short_term_max, color='gray', linestyle='--', linewidth=1, alpha=0.5)
    ax2.text(short_term_max, ax2.get_ylim()[1]*0.95, f'Short-term\nregion', 
            fontsize=8, ha='right', va='top', color='gray')
    
    ax2.set_xlabel('Recovery Time (Generations since shock end)', fontsize=12)
    ax2.set_ylabel('Average Quality', fontsize=12)
    ax2.set_title(f'Quality Recovery Trajectory\nμ={mu}, ι={hgt}, Replicate={replicate+1}',
                 fontsize=14, fontweight='bold')
    ax2.legend(fontsize=9, loc='best')
    ax2.grid(True, alpha=0.3)
    
    # 添加衰减率信息框
    textstr = (f'Short-term λ: {lambda_quality_short:.3f} (A={A_quality_short:.1f})\n'
              f'Long-term λ: {lambda_quality_long:.3f} (A={A_quality_long:.1f})')
    ax2.text(0.02, 0.98, textstr, transform=ax2.transAxes, fontsize=9,
            verticalalignment='top', bbox=props)
    
    plt.tight_layout()
    
    # 保存图片
    filename = f'dual_fit_recovery_mu{mu}_hgt{hgt}_rep{replicate}.png'
    plt.savefig(filename, dpi=300, bbox_inches='tight')
    plt.close()
    
    print(f"生成: {filename}")
    
    return {
        'mu': mu, 'hgt': hgt, 'replicate': replicate,
        'price_short_lambda': lambda_price_short,
        'price_long_lambda': lambda_price_long,
        'quality_short_lambda': lambda_quality_short,
        'quality_long_lambda': lambda_quality_long,
        'price_short_amplitude': A_price_short,
        'price_long_amplitude': A_price_long,
        'quality_short_amplitude': A_quality_short,
        'quality_long_amplitude': A_quality_long,
        'target_price': target_price,
        'target_quality': target_quality
    }

def create_combined_3x6_subplots():
    """创建3行6列总图 - 完美匹配18张子图"""
    # 获取所有生成的图片文件
    image_files = [f for f in os.listdir('.') if f.startswith('dual_fit_recovery_mu') and f.endswith('.png')]
    
    if not image_files:
        print("未找到生成的图片文件")
        return
    
    # 排序图片文件确保顺序一致
    image_files = sorted(image_files)
    
    # 检查图片数量
    num_images = len(image_files)
    if num_images != 18:
        print(f"警告: 期望18张图，实际找到{num_images}张图")
        print("但仍将创建3x6布局")
    
    # 3行6列网格
    rows, cols = 3, 6
    
    print(f"创建 {rows}x{cols} 总图，共 {num_images} 张图片")
    
    # 创建图形 - 调整大小适应3×6布局
    # 每列宽5英寸，每行高4英寸
    fig, axes = plt.subplots(rows, cols, figsize=(cols*5, rows*4))
    
    # 设置主标题
    fig.suptitle('Dual-Fit Recovery Analysis: Short-term vs Long-term Exponential Fitting\nComplete Parameter Space (3μ × 3ι × 2 replicates = 18 combinations)',
                fontsize=20, fontweight='bold', y=0.98)
    
    # 扁平化axes数组以便遍历
    axes_flat = axes.flatten()
    
    # 显示图片
    for i, image_file in enumerate(image_files):
        if i >= len(axes_flat):
            print(f"警告: 图片数量({num_images})超过{rows}x{cols}网格容量({rows*cols})")
            break
            
        # 读取并显示图片
        img = plt.imread(image_file)
        axes_flat[i].imshow(img)
        axes_flat[i].axis('off')
        
        # 从文件名提取参数信息
        filename = image_file.replace('dual_fit_recovery_', '').replace('.png', '')
        parts = filename.split('_')
        
        if len(parts) >= 3:
            mu_val = parts[0].replace('mu', '')
            hgt_val = parts[1].replace('hgt', '')
            rep_val = parts[2].replace('rep', '')
            
    
    # 如果图片数量少于36，隐藏多余的空格子图
    for i in range(num_images, len(axes_flat)):
        axes_flat[i].axis('off')
        # 可选：在空白位置添加说明
        if i == len(axes_flat) - 1 and num_images < len(axes_flat):
            axes_flat[i].text(0.5, 0.5, f'Empty cells\n({num_images}/{rows*cols} filled)', 
                             transform=axes_flat[i].transAxes,
                             ha='center', va='center', fontsize=12,
                             style='italic', alpha=0.5)
    
    # 添加布局说明
    fig.text(0.02, 0.02, 
             'Layout: 3 rows × 6 columns = 18 parameter combinations\nμ values: 0.2, 0.6, 1.0 (rows) | ι values: 0.2, 0.6, 1.0 (columns) | 2 replicates each',
             fontsize=10, style='italic', alpha=0.8)
    
    plt.tight_layout(rect=[0.03, 0.03, 1, 0.97])  # 调整边距
    
    output_file = 'combined_3x6_dual_fit_recovery.svg'
    plt.savefig(output_file, dpi=250, bbox_inches='tight')  # 降低DPI以适应大图
    plt.close()
    print(f"生成: {output_file}")
    print(f"  总图尺寸: {cols*5}×{rows*4} 英寸，包含 {num_images} 个子图")

def create_continuous_attenuation_summary(df, results):
    """创建连续的衰减率总结图（使用协调的颜色风格）"""
    if not results:
        return
    
    # 转换为DataFrame
    results_df = pd.DataFrame(results)
    
    # 创建图形 - 使用协调的颜色方案
    fig, axes = plt.subplots(2, 2, figsize=(18, 14))
    
    # 准备插值数据
    mu_min, mu_max = df['mu'].min(), df['mu'].max()
    hgt_min, hgt_max = df['hgt'].min(), df['hgt'].max()
    
    # 创建密集网格用于插值
    mu_grid = np.linspace(mu_min, mu_max, 100)
    hgt_grid = np.linspace(hgt_min, hgt_max, 100)
    MU, HGT = np.meshgrid(mu_grid, hgt_grid)
    
    from scipy.interpolate import griddata
    
    # 1. 短期价格衰减率
    pivot_price_short = results_df.groupby(['mu', 'hgt'])['price_short_lambda'].mean().reset_index()
    points = pivot_price_short[['mu', 'hgt']].values
    values_price_short = pivot_price_short['price_short_lambda'].values
    Z_price_short = griddata(points, values_price_short, (MU, HGT), method='cubic')
    
    im1 = axes[0,0].contourf(MU, HGT, Z_price_short, levels=50, cmap='viridis')
    axes[0,0].scatter(points[:,0], points[:,1], c='white', s=50, edgecolors='black', alpha=0.8)
    axes[0,0].set_xlabel('Mutation Rate (μ)', fontsize=11)
    axes[0,0].set_ylabel('Horizontal Gene Transfer (ι)', fontsize=11)
    axes[0,0].set_title('Short-term Price Recovery Rate (λ)\nHigher = Faster Recovery',
                       fontsize=12, fontweight='bold', pad=10)
    cbar1 = plt.colorbar(im1, ax=axes[0,0])
    cbar1.set_label('Attenuation Rate', rotation=270, labelpad=15)
    
    # 2. 长期价格衰减率
    pivot_price_long = results_df.groupby(['mu', 'hgt'])['price_long_lambda'].mean().reset_index()
    values_price_long = pivot_price_long['price_long_lambda'].values
    Z_price_long = griddata(points, values_price_long, (MU, HGT), method='cubic')
    
    im2 = axes[0,1].contourf(MU, HGT, Z_price_long, levels=50, cmap='plasma')
    axes[0,1].scatter(points[:,0], points[:,1], c='white', s=50, edgecolors='black', alpha=0.8)
    axes[0,1].set_xlabel('Mutation Rate (μ)', fontsize=11)
    axes[0,1].set_ylabel('Horizontal Gene Transfer (ι)', fontsize=11)
    axes[0,1].set_title('Long-term Price Recovery Rate (λ)\nHigher = Faster Recovery',
                       fontsize=12, fontweight='bold', pad=10)
    cbar2 = plt.colorbar(im2, ax=axes[0,1])
    cbar2.set_label('Attenuation Rate', rotation=270, labelpad=15)
    
    # 3. 短期质量衰减率
    pivot_quality_short = results_df.groupby(['mu', 'hgt'])['quality_short_lambda'].mean().reset_index()
    values_quality_short = pivot_quality_short['quality_short_lambda'].values
    Z_quality_short = griddata(points, values_quality_short, (MU, HGT), method='cubic')
    
    im3 = axes[1,0].contourf(MU, HGT, Z_quality_short, levels=50, cmap='gist_earth')
    axes[1,0].scatter(points[:,0], points[:,1], c='white', s=50, edgecolors='black', alpha=0.8)
    axes[1,0].set_xlabel('Mutation Rate (μ)', fontsize=11)
    axes[1,0].set_ylabel('Horizontal Gene Transfer (ι)', fontsize=11)
    axes[1,0].set_title('Short-term Quality Recovery Rate (λ)\nHigher = Faster Recovery',
                       fontsize=12, fontweight='bold', pad=10)
    cbar3 = plt.colorbar(im3, ax=axes[1,0])
    cbar3.set_label('Attenuation Rate', rotation=270, labelpad=15)
    
    # 4. 长期质量衰减率
    pivot_quality_long = results_df.groupby(['mu', 'hgt'])['quality_long_lambda'].mean().reset_index()
    values_quality_long = pivot_quality_long['quality_long_lambda'].values
    Z_quality_long = griddata(points, values_quality_long, (MU, HGT), method='cubic')
    
    im4 = axes[1,1].contourf(MU, HGT, Z_quality_long, levels=50, cmap='flare')
    axes[1,1].scatter(points[:,0], points[:,1], c='white', s=50, edgecolors='black', alpha=0.8)
    axes[1,1].set_xlabel('Mutation Rate (μ)', fontsize=11)
    axes[1,1].set_ylabel('Horizontal Gene Transfer (ι)', fontsize=11)
    axes[1,1].set_title('Long-term Quality Recovery Rate (λ)\nHigher = Faster Recovery',
                       fontsize=12, fontweight='bold', pad=10)
    cbar4 = plt.colorbar(im4, ax=axes[1,1])
    cbar4.set_label('Attenuation Rate', rotation=270, labelpad=15)
    
    # 添加整体标题
    plt.suptitle('Dual-Fit Recovery Dynamics Summary\nComparison of Short-term vs Long-term Recovery Rates',
                fontsize=16, fontweight='bold', y=0.98)
    plt.tight_layout(rect=[0, 0, 1, 0.95])
    plt.savefig('continuous_dual_fit_attenuation_summary.svg', dpi=300, bbox_inches='tight')
    plt.close()
    print("生成: continuous_dual_fit_attenuation_summary.svg")

def main():
    """主函数"""
    # 读取数据
    try:
        df = pd.read_csv('market_evolution_adaptive_convergence.csv')
        print(f"数据加载成功: {len(df)} 条记录")
    except FileNotFoundError:
        print("错误: 找不到数据文件 'market_evolution_adaptive_convergence.csv'")
        return
    
    # 存储所有分析结果
    all_results = []
    print("开始生成双拟合恢复分析图...")
    
    # 为每个参数组合生成双拟合图
    for mu in df['mu'].unique():
        for hgt in df['hgt'].unique():
            for replicate in [0, 1]:
                result = plot_dual_fit_recovery(df, mu, hgt, replicate, short_term_max=10)
                if result:
                    all_results.append(result)
    
    print(f"\n成功生成 {len(all_results)} 个双拟合分析图")
    
    # 生成3×6总图
    print("\n生成3×6总图...")
    create_combined_3x6_subplots()
    
    # 生成连续衰减率总结
    print("\n生成连续衰减率总结...")
    create_continuous_attenuation_summary(df, all_results)
    
    # 保存分析结果
    if all_results:
        results_df = pd.DataFrame(all_results)
        results_df.to_csv('dual_fit_recovery_analysis_results.csv', index=False)
        print(f"\n分析结果保存至: dual_fit_recovery_analysis_results.csv")
    
    print("\n所有图表生成完成!")

if __name__ == "__main__":
    main()
